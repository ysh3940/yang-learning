package cn.yang.learning.notes.note2025项目;

public class mysql笔记 {

    // mysql分库分表，和redis分片一致
    // 设计案例：电商订单系统
    // 某电商平台采用分库分表（256分片）与Redis Cluster（256节点，每个节点管理64哈希槽）：
    // 写入：订单按用户ID分片写入数据库分片5，同步写入Redis槽位320-383（5 * 64=320）。
    // 查询：用户访问订单列表时，直接命中Redis分片5，仅未命中时穿透至数据库分片5。
    // 扩容：数据库分片扩容至512时，Redis槽位同步扩展至32768（通过虚拟节点调整），仅需迁移50%数据。

    // mysql事物隔离级别
    // 隔离级别对比总结
    //  隔离级别	     脏读	不可重复读	幻读	性能
    //  读未提交	      ✔️	✔️	        ✔️	最高
    //  读已提交	      ❌	✔️	        ✔️	较高
    //  可重复读（默认） ❌	❌	        ❌	中等
    //  串行化	      ❌	❌	        ❌	最低
    //  *注：InnoDB 在可重复读级别通过 MVCC 和间隙锁避免了幻读。

    // select * from table1 where id =1 for update 会触发哪些锁？
    //    1. 行锁（Record Lock）
    //       作用：锁定索引中具体的行记录（若id=1存在且id是主键或唯一索引）。
    //       触发条件：当查询条件命中唯一索引或主键时，InnoDB会直接对目标行加排他锁（X锁）。
    //       兼容性：排他锁与其他所有锁（包括共享锁、间隙锁等）均不兼容，其他事务无法对该行进行修改或加锁。
    //    2. 间隙锁（Gap Lock） （触发场景：）
    //       触发条件（仅限可重复读隔离级别）：
    //       若id=1不存在，则锁定该值所在索引区间的间隙，防止其他事务插入id=1的数据。
    //       若id是非唯一索引，即使id=1存在，InnoDB也会对相邻区间加间隙锁（例如防止其他事务插入id=0.5或id=2的数据）。
    //    3. 临键锁（Next-Key Lock）
    //       触发条件（默认在可重复读隔离级别下）：
    //       当id是非唯一索引或查询范围不明确时，InnoDB会将间隙锁+记录锁组合为临键锁，锁定左开右闭的区间（如(0, 1]）。
    //       若id是主键或唯一索引且id=1存在，临键锁会退化为记录锁，仅锁定当前行。
    //    4. 意向排他锁（IX锁）
    //       作用：在加行级排他锁前，InnoDB会自动对表加意向排他锁（IX锁），表明事务意图修改表中的某些行。
    //       兼容性：IX锁与表级共享锁（S）、排他锁（X）冲突，但允许其他事务对表加IX锁。

    // MySQL 中间隙锁（Gap Lock）的触发场景
    //    1. 事务隔离级别为可重复读（RR）
    //       间隙锁仅在 可重复读（Repeatable Read） 隔离级别下生效，目的是防止幻读（Phantom Read）。
    //       在 读已提交（Read Committed） 隔离级别下，间隙锁通常不会生效。
    //    2. 查询涉及范围或未命中记录的等值条件
    //       范围查询：如 SELECT ... WHERE id > 5 FOR UPDATE，会锁定索引记录之间的间隙。
    //       等值查询未命中记录：如 SELECT ... WHERE id = 7（假设 id=7 不存在），会锁定 id=7 所在的间隙。
    //    3. 索引为非唯一索引
    //       非唯一索引的查询会触发间隙锁，因为需要防止其他事务在索引间隙中插入相同值的记录。
    //       唯一索引的等值查询若命中记录，则退化为行锁（Record Lock），但若未命中仍会触发间隙锁。




}
