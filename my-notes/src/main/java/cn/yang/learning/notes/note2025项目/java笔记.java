package cn.yang.learning.notes.note2025项目;

public class java笔记 {

    // 线程池的参数是怎么设计的，为啥Tomcat的线程池可以设置为200？
    // 一、线程池核心参数设计原则
    //线程池的核心参数包括：
    //
    //核心线程数（corePoolSize）
    //常驻线程数，用于快速响应任务。根据任务类型调整：
    //
    //CPU密集型（如计算类任务）：通常设置为CPU核数+1（如8核设9线程），避免过多线程导致上下文切换。
    //IO密集型（如网络请求、数据库操作）：线程数可设置为CPU核数×2或更高（如8核设16线程），因线程大部分时间处于等待IO状态，需更多线程提高吞吐量。
    //最大线程数（maximumPoolSize）
    //应对突发流量，建议设置为核心线程数的1.5~2倍。但需结合队列容量，避免队列过长导致延迟或内存溢出。
    //
    //任务队列（workQueue）
    //
    //有界队列（如LinkedBlockingQueue）：防止任务堆积引发OOM，队列容量需根据任务处理速度和峰值流量动态调整。
    //无界队列风险：默认队列如SynchronousQueue可能导致请求直接进入最大线程，需谨慎设置。
    //拒绝策略（handler）
    //当队列和线程池均满时，需合理选择策略：
    //
    //CallerRunsPolicy：由调用线程处理任务，适合降级场景。
    //AbortPolicy：直接抛出异常，适合关键业务快速失败。
    //线程空闲时间（keepAliveTime）
    //非核心线程的空闲回收时间，资源紧张时可启用核心线程超时回收（allowCoreThreadTimeOut=true）。
    //
    //二、Tomcat线程池为何设置为200？
    //Tomcat默认最大线程数为200，其设计逻辑如下：
    //
    //IO密集型任务特性
    //Tomcat处理HTTP请求时，大部分时间消耗在网络IO（如数据库查询、RPC调用），而非CPU计算。线程在等待IO时可释放CPU资源，允许更多线程并行处理其他请求，从而提高吞吐量。
    //
    //线程池实现机制差异
    //
    //JDK线程池：任务先入队，队列满后才创建新线程（核心→队列→最大）。
    //Tomcat线程池：优先使用最大线程数，队列仅作为缓冲（核心→最大→队列）。当请求量突增时，Tomcat会快速创建线程至最大值（200），减少任务排队延迟。
    //队列容量优化
    //Tomcat默认使用TaskQueue（继承自LinkedBlockingQueue），其实际队列容量为Integer.MAX_VALUE，仅在达到最大线程数后才会入队。这种设计避免了队列过早堆积，优先通过扩展线程处理请求。
    //
    //资源利用与监控
    //
    //CPU利用率：若线程繁忙但CPU使用率低（如等待IO），说明线程数未达瓶颈，可适当调高。
    //动态调整：通过监控活跃线程数（activeThreads）和队列长度（queueSize），结合压测结果优化参数。








}
