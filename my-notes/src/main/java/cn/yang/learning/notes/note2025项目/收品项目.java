package cn.yang.learning.notes.note2025项目;

public class 收品项目 {

    // 详细流程


    // 难点
    // 1、单活动数据巨大，es和mysql都要分库，2个库之间就会产生数据同步的问题，以及数据同步下游的问题
    // 解决方法，mysql分64X256，es分6集群单活动一个索引，分库设计活动code+报名人去路由，数据同步安报名人裂变去扫数据
    // mysql和es数据同步，采用mq实现最终数据一致性，mq内部异常支持重试



    // 成长
    // 1、系统的架构设计能力 2、大数量的存储+同步 3、大数量下性能优化 4、mysql+es间的数据一致性 5、系统的监控意识以及发现问题及时处理

    // 系统中还存在哪里问题、哪些优化点等
    // 1、当前mysql按活动+报名人分片，无法做到完全的数据分散，写入性能依赖单分片性能
    // 2、es按活动纬度创建索引，一个活动16个分片，在活动多的情况下，会导致分片数过多（冷数据要及时归档）
    // TODO


    // 全量已报数据同步方案：
    // 1.流式同步，边报名边同步 mq或接口同步 （标 或 券）
    // 2.泄洪式同步，活动一开始，扫出来全量已报sku全量同步，增量数据边报边同步 （科技侧：先享后付业务团队）
    // 3.离线表T+1 同步 （页面搭建上场）



    // sku退出活动需要审核，6小时内未审核的自动审批通过（底层方法一定要支持幂等）
    // 方案：基于任务区实现，首先jmq的延迟消费只支持1小时，无法满足
    // 定时任务每5秒触发一次，扫描100条待处理的任务，处理完直接删除，任务记录归档都一个历史表
    // 任务表设计，type + status + 活动code + sku + 开始执行时间(加索引) + 结束执行时间


    // 创建收品活动过程中需要调用多个上游接口，如何实现数据一致性
    // 一、事务型方案
    // TCC（Try-Confirm-Cancel）柔性事务
    // 核心流程：
    // Try阶段：冻结资源（如预留库存、锁定优惠券），所有RPC接口完成资源预占并返回准备状态24。
    // Confirm阶段：若所有Try成功，提交所有操作（如实际扣减库存、发放积分），此阶段需保证接口幂等23。
    // Cancel阶段：任一Try失败则触发补偿（如释放库存、回退优惠券），补偿操作需支持重试和幂等24。
    // 优势：避免长期锁资源，适合高并发场景。
    // 案例：电商活动创建时，先冻结库存再确认扣减，失败则解冻。
    // 两阶段提交（2PC） 
    // Prepare阶段：协调者询问所有RPC接口是否可提交，参与者预写日志但不提交16。
    // Commit/Rollback阶段：若所有参与者同意，则提交事务；否则回滚16。
    // 局限：存在同步阻塞和单点故障风险，性能较低16。
    //
    // 二、非事务型方案
    // 幂等性设计
    // 实现方式：
    // 唯一业务ID：为每个活动创建请求生成唯一ID，各RPC接口基于ID去重45。
    // 版本号控制：数据更新时携带版本号，冲突时拒绝操作13。
    // 适用场景：重试敏感型接口（如扣减库存、发放奖励）35。
    // 异步消息队列
    // 流程：
    //本地事务中写入活动主数据并发送消息到MQ26。
    //消费者订阅消息，顺序调用RPC接口，失败时重试或进死信队列26。
    // 保障机制：MQ需支持至少一次投递和顺序消费6。
    // 案例：通过Kafka保证活动创建与积分发放的最终一致性。
    // 补偿机制（Saga模式） --------------------推荐使用这种---------------------
    // 正向操作：依次调用RPC接口，每个接口完成后记录日志46。
    // 反向补偿：任一接口失败时，按日志逆序触发补偿接口（如已扣库存则回滚）46。
    // 关键点：补偿接口需幂等，且需设计超时重试策略4。
    //
    // 三、辅助增强策略
    // 分布式锁
    // 作用：防止并发请求导致资源冲突（如库存超卖）13。
    // 实现：基于Redis或ZooKeeper实现锁机制，锁粒度细化到具体资源13。
    // 数据核对与修复
    // 定时任务：扫描未完成的事务，触发补偿或人工干预46。
    // 对账系统：对比各系统数据状态（如活动状态与库存扣减记录），修复不一致4。
    // 版本号与状态机
    // 版本号：活动数据每次变更递增版本，RPC调用携带版本号验证13。
    // 状态机：定义活动生命周期状态（如“创建中”“已生效”），拒绝非法状态转换4。
    //
    // 四、技术选型建议
    // 场景	 推荐方案	 理由
    // 高并发、短耗时操作	TCC + 幂等性	避免长事务阻塞，兼顾性能与一致性24
    // 最终一致性容忍场景	异步消息队列 + 补偿	吞吐量高，适合跨系统协作26
    // 强一致性要求（如金融）	2PC + 分布式锁	牺牲部分性能换取强一致16
    // 五、实践注意事项
    //
    // 接口设计：所有RPC接口需支持幂等、超时重试和明确的状态返回值34。
    // 日志追踪：通过全局事务ID串联所有RPC调用链路，便于排查问题46。
    // 降级策略：在MQ或补偿服务故障时，启用人工干预通道4。
    // 性能权衡：根据业务容忍度选择强一致或最终一致，避免过度设计16。
    // 通过以上方案组合，可有效解决多RPC调用的数据一致性问题。实际落地时需结合业务场景（如活动类型、并发量）选择合适策略，并通过压测验证可靠性26。

}
