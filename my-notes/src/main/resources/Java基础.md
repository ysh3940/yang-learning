1、过滤器和拦截器的区别<br>
filter是基于servlet容器的，intercept是基于spring容器的<br>
请求流程：filter pre（进入过滤器，执行chain.Filter方法前），service（servlet的doService方法），dispatcher（springMVC的请求分发方法），preHandler，controller，postHandler（多了ModelAndView参数）（control执行完了，处理了，但是还并未传递到网页模板进行渲染，return之前），afterCompletion（control的return之后），filter after<br>
Filter 的生命周期：当用户请求某个页面时候，会到web.xml中匹配是否存在能够匹配上此次请求的filter，如果有封装它的配置信息，FilterChain链。然后调用init方法，完成初始化，接着调用dofilter方法，处理核心逻辑，当此实例被销毁的时候，会调用destroy方法。


2、string的intern方法<br>
显示把字符串加入到常量池<br>

如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回


4、jdk动态代理和cglib的区别<br>
JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。<br>
JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。<br>
JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法（直接调用父类方法），Cglib执行效率更高。<br>

天天的都听到人们说JDK动态代理，听上去感觉好屌的样子，为什么要叫JDK动态代理？
是因为代理对象是由JDK动态生成的，而不像静态代理方式写死代理对象和被代理类，不灵活。
JDK动态代理基于拦截器和反射来实现。
JDK代理是不需要第三方库支持的，只需要JDK环境就可以进行代理，使用条件：
1）必须实现InvocationHandler接口；
2）使用Proxy.newProxyInstance产生代理对象；
3）被代理的对象必须要实现接口；

CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，
它可以在运行期扩展Java类与实现Java接口。Hibernate用它来实现PO(Persistent Object 持久化对象)字节码的动态生成。
CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供
方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。
除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，
因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。


Java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br>
而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。<br>
1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换<br>
如何强制使用CGLIB实现AOP？<br>
（1）添加CGLIB库，SPRING_HOME/cglib/*.jar<br>
（2）在spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/><br>
JDK动态代理和CGLIB字节码生成的区别？<br>
（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br>
（2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>
因为是继承，所以该类或方法最好不要声明成final<br>


5、instanceof的实现原理<br>（https://blog.csdn.net/A_BCDEF_/article/details/96443019）
S instanceof T：s为null直接false，s == t直接true，s分为3种情况（数组、接口、类）<br>
①、S是数组类型：如果 T 是一个类类型，那么T必须是Object；如果 T 是接口类型，那么 T 必须是由数组实现的接口之一；<br>
②、接口类型：对接口类型的 instanceof 就直接遍历S里记录的它所实现的接口，看有没有跟T一致的；<br>
③、类类型：对类类型的 instanceof 则是遍历S的super链（继承链）一直到Object，看有没有跟T一致的。遍历类的super链意味着这个算法的性能会受类的继承深度的影响。<br>


7、基本数据类型以及包装类，以及引用数据类型<br>
boolean - Boolean：只有两个取值：true 和 false<br>
byte - Byte：      1字节8位，最小值为：-128（-2^7）， 最大值为：127（2^7-1）<br>
short - Short：    2字节16位， 最小值为：-32768（-2^15），最大值为：32767（2^15 - 1）<br>
char - Character： 2字节，是一个单一的 16 位 Unicode 字符；最小值： \u0000（即为0），最大值： \uffff（即为65,535），作用：char数据类型可以存储任何字符<br>
int - Integer：    4字节32位，最小值为：-2,147,483,648（-2^31），最大值为：2,147,483,647（2^31 - 1）<br>
long - Long：      8字节64位，最小值为：-9,223,372,036,854,775,808（-2^63），最大值为：9,223,372,036,854,775,807（2^63 -1）<br>
float - Float：    4字节32位，最小值为：1.4E - 45，最大值为：3.4028235E38（单精度，0.0f）<br>
double - Double：  8字节64位，最小值为：4.9E-324，最大值为：1.7976931348623157E308（双精度，0.0d）<br>
Integer缓存：通过valueOf创建Integer对象的时候，如果数值在区间[-128，127]，那么便返回指向IntegerCache.cache数组中已经存在的对象的引用；否则创建一个新的Integer对象。简而言之，创建Integer包装器时，有一个数值在[-128，127]的缓冲池。当创建的对象数值在[-128，127]之间时，那么不需要再在内存中开辟一个空间存储，只需要将当前对象的引用指向该缓冲池中对应的对象，这样效率上得到了提高，资源也没有浪费<br>
Integer i1 = 2;Integer i2 = Integer.valueOf(2);i1 == i2返回的是true（如果i2是new出来的则是false）<br>
引用数据类型：类class、接口interface、数组<br>

9、AQS队列<br>（https://blog.csdn.net/Thousa_Ho/article/details/78047634）
ReentrantLock（独占锁）流程：<br>
锁是否空闲<br>
锁是否被当前线程占用<br>
线程入队列，前驱节点是够head节点 && 尝试获取锁（成功=设值当前节点为head节点）<br>
找到安全节点（park挂起线程）<br>
unPark唤醒线程，前驱节点是够head节点 && 尝试获取锁（成功=设值当前节点为head节点，失败继续找安全节点）<br>


10、引用类型（强，软，弱，虚）<br>
强引用：在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>
软引用：用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。<br>
弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<br>
虚引用：也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。<br>

11、多态<br>
多态是同一个行为具有多个不同表现形式或形态的能力，多态就是同一个接口，使用不同的实例而执行不同操作。（消除类型之间的耦合关系、可替换性、可扩充性、灵活性）<br>
多态的实现方式：Java 重写(Override)与重载(Overload)、接口、抽象类和抽象方法<br>


13、String能被继承吗？为什么？<br>
不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str=”a”;其实和String str=new String(“a”)还是有差异的。<br>
String str = "a"; 这个只是一个引用，内存中如果有“a"的话，str就指向它；如果没有，才创建它;<br>
  如果你以后还用到"a"这个字符串的话并且是这样用：<br>
  String str1 = "a"; String str2 = "a"; String str2 = "a"; 这4个变量都共享一个字符串"a"。<br>
  而String str = new String("a");是根据"a"这个String对象再次构造一个String对象，将新构造出来的String对象的引用赋给str<br>

14、String， Stringbuffer， StringBuilder 的区别。<br>
StringBuffer 字符串变量（线程安全）,其也是final类别的，不允许被继承，其toString方法会进行对象缓存，以减少元素复制开销。<br>
StringBuilder 字符串变量（非线程安全）,其也是final类别的，不允许被继承，不同之处在于最后toString的时候，会直接返回一个新对象。<br>

15、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。<br>
此题考察的是类加载器实例化时进行的操作步骤（加载–>连接（验证、准备、解析）->初始化）。<br>
父类静态代变量、 父类静态代码块、 <br>
子类静态变量、 子类静态代码块、 <br>
父类非静态变量（父类实例成员变量）、<br> 
父类构造函数、 <br>
子类非静态变量（子类实例成员变量）、 <br>
子类构造函数<br>

加载：查找并加载类的二进制数据（1、通过一个类的全限定名来获取其定义的二进制字节流。2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。）<br>
验证：确保被加载的类的正确性（文件格式验证、元数据验证、字节码验证、符号引用验证）<br>
准备：为类的静态变量分配内存，并将其初始化为默认值（0，false之类的，static final的编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3）<br>
解析：把类中的符号引用转换为直接引用（直接其在内存中的直接引用）（解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。）<br>
初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：①声明类变量是指定初始值、②使用静态代码块为类变量指定初始值<br>


16、用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。<br>
hashMap是线程不安全的，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，采用哈希表来存储的<br>
hashMap,linkedHashMap,treeMap,hashTable

17、有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。<br>
TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）。 <br>

18、抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。<br>
抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 <br>
抽象类要被子类继承，接口要被类实现。 <br>
接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 <br>
接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br> 
抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 <br>
抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 <br>
抽象类里可以没有抽象方法 <br>
如果一个类里有抽象方法，那么这个类只能是抽象类 <br>
抽象方法要被实现，所以不能是静态的，也不能是私有的。<br> 
接口可继承接口，并可多继承接口，但类只能单根继承。<br>

19、继承和聚合的区别在哪。<br>
继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性； <br>
聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；<br>

20、反射的原理，反射创建类实例的三种方式是什么<br>
第一种，使用 Class.forName 静态方法。(前提：已明确类的全路径名。)<br>
第二种，使用 .class 方法。(说明：仅适合在编译前就已经明确要操作的 Class)<br>
第三种，使用类对象的 getClass() 方法。(适合有对象示例的情况下)<br>


21、反射中，Class.forName 和 ClassLoader 区别。<br>
类的加载过程:<br>
装载：查找和导入类或接口的二进制数据； <br>
链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； <br>
校验：检查导入类或接口的二进制数据的正确性； <br>
准备：给类的静态变量分配并初始化存储空间； <br>
解析：将符号引用转成直接引用； <br>
初始化：激活类的静态变量的初始化Java代码和静态Java代码块。<br>
Class.forName(className)方法，其实调用的方法是Class.forName(className,true,classloader);注意看第2个boolean参数，它表示的意思，在loadClass后必须初始化。比较下我们前面准备jvm加载类的知识，我们可以清晰的看到在执行过此方法后，目标对象的 static块代码已经被执行，static参数也已经被初始化。<br>
ClassLoader.loadClass(className)方法，其实他调用的方法是ClassLoader.loadClass(className,false);还是注意看第2个 boolean参数，该参数表示目标对象被装载后不进行链接，这就意味这不会去执行该类静态块中间的内容。因此2者的区别就显而易见了。<br>

22、描述动态代理的几种实现方式，分别说出相应的优缺点。动态代理与 cglib 实现的区别，为什么 CGlib 方式可以对接口实现代理。<br>
jdk底层是利用反射机制，需要基于接口方式（基于invocationHandler）<br>
Cglib则是基于asm框架，实现了无反射机制进行代理，利用空间来换取了时间，代理效率高于jdk （基于methodInterceptor）<br>


23、final 的用途，类、变量、方法 <br>
final变量是只读的。凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。<br>
final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。<br>
使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。<br>

下面总结了一些使用final关键字的好处<br>
final关键字提高了性能。JVM和Java应用都会缓存final变量。<br>
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。<br>
使用final关键字，JVM会对方法、变量及类进行优化。<br>

24、写出三种单例模式实现。<br>
双重校验锁、静态内部类、枚举类<br>

25、说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。<br>
equals与hashcode的关系 <br>
equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。 <br>
当hashMap的key是自定义的对象的时候，需要重写这2个方法，需要保证这2个方法计算逻辑一致<br>

26、深拷贝和浅拷贝区别。<br>
浅拷贝：会对“主”对象进行拷贝，但不会复制主对象里面的对象。"里面的对象“会在原来的对象和它的副本之间共享。例如，我们会为一个 Person对象创建第二个 Person 对象, 而两个 Person 会共享相同的 Name 和 Address 对象。<br>
当我们在一个对象中修改了 Address 对象，那么也就表示两个对象总的 Address 都被修改了。<br>
深拷贝：不同于浅拷贝，深拷贝是一个整个独立的对象拷贝。如果我们对整个 Person对象进行深拷贝，我们会对整个对象的结构都进行拷贝。<br>

27、数组和链表数据结构描述，各自的时间复杂度<br>
数组：是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。<br>
链表：中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储 数据元素 的　数据域，另一个是存储下一个结点地址的 指针。 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。<br>

28、error 和 exception 的区别，CheckedException，RuntimeException 的区别<br>
Throwable是所有异常的根，java.lang.Throwable<br>
Error是错误，java.lang.Error（当程序发生不可控的错误时，通常做法是通知用户并中止程序的执行。与异常不同的是Error及其子类的对象不应被抛出。）<br>
Exception是异常，java.lang.Exception<br>

Checked异常（1 当前方法知道如何处理该异常，则用try...catch块来处理该异常。2 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。）<br>
Java.lang.ClassNotFoundException<br>
Java.lang.NoSuchMethodException<br>
java.io.IOException<br>

RuntimeException（如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。）<br>
Java.lang.ArithmeticException<br>
Java.lang.ArrayStoreExcetpion<br>
Java.lang.ClassCastException<br>
Java.lang.IndexOutOfBoundsException<br>
Java.lang.NullPointerException<br>


30、有没有可能 2 个不相等的对象有相同的 hashcode。<br>
有<br>

31、什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。<br>
Java为了方便开发人员将Java对象进行序列化及反序列化提供了一套方便的API来支持。其中包括以下接口和类：<br>
java.io.Serializable<br>
java.io.Externalizable（writeExternal、readExternal）<br>
ObjectOutput<br>
ObjectInput<br>
ObjectOutputStream<br>
ObjectInputStream<br>
Transient 关键字<br>
Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<br>

33、TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。<br>
三次握手：<br>
第一次握手(SYN=1, seq=x):<br>
客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。<br>

第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):<br>
服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。<br>

第三次握手(ACK=1，ACKnum=y+1)<br>
客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。<br>

思考：为什么要三次握手呢，有人说两次握手就好了<br>
举例：已失效的连接请求报文段。<br>
client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。<br>

四次挥手：<br>
第一次挥手(FIN=1，seq=x)<br>
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。<br>

第二次挥手(ACK=1，ACKnum=x+1)<br>
服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。<br>

第三次挥手(FIN=1，seq=y)<br>
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。<br>

第四次挥手(ACK=1，ACKnum=y+1)<br>
客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。<br>
客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 两次后会重传直到超时。如果多了会有大量半链接阻塞队列。 <br>

思考：那么为什么是4次挥手呢？<br>
为了确保数据能够完成传输。关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。<br>

34、简述 Http 请求 get 和 post 的区别以及数据包格式。<br>
一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成<br>
请求行：由请求方法字段（GET、POST、PUT等）、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。<br>
请求头部：由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。<br>
请求数据：不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。<br>

35、说说你知道的几种 HTTP 响应码，比如 200, 302, 404。<br>
1xx：信息，请求收到，继续处理 <br>
2xx：成功，行为被成功地接受、理解和采纳 <br>
3xx：重定向，为了完成请求，必须进一步执行的动作 <br>
4xx：客户端错误，请求包含语法错误或者请求无法实现 <br>
5xx：服务器错误，服务器不能实现一种明显无效的请求 <br>
200 ok 一切正常 <br>
302 Moved Temporatily 文件临时移出 <br>
404 not found <br>

36、当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。<br>
Dns解析–>端口分析–>tcp请求–>服务器处理请求–>服务器响应–>浏览器解析—>链接关闭<br>
