1、CAP<br>
CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得<br>
P-分区容错性：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，在实际情况中只能满足其中一个<br>
放弃分区：意味着系统的扩展性，也就是分布式节点受限，没办法部署子节点<br>

2、分布式事物<br>
银行转账问题，银行A向银行B转100元，怎么保证数据一致？使用TCC事物方案，T：冻结金额、C：确认扣减或增加、C：取消扣减或添加<br>

3、分库分表中间件<br>
sharding-jdbc：当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。<br>
mycat：基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。<br>

4、单一表怎么迁移到分库分表<br>
停机迁移方案<br>
双写迁移方案：简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，除了对老库增删改，都加上对新库的增删改，这就是所谓的双写，同时写俩库，老库和新库。然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。<br>

5、怎么设计一个分库分表的方案<br>
一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。刚开始的时候，这个库可能就是逻辑库，建在一个数据库服务上的，就是一个mysql服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。<br>

6、分库分表多维度列表查询怎么设计（用户订单列表，商户订单列表）<br>
订单主表根据订单ID在做hash算法，需要再设计一个索引表已用户ID做hash算法（商户类似）<br>

7、怎么使用redis、zookeeper实现分布式锁（如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。）<br>
首先分布式锁实现常见的有数据库锁(表记录)，缓存锁，基于zk（临时有序节点可以实现的）的三种<br>
Redis适用于对性能要求特别高的场景。redis可以每秒执行10w次，内网延迟不超过1ms <br>
缺点是数据存放于内存，宕机后锁丢失。<br>
锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。<br>
非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。<br>
不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。<br>
单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。<br>
1.基于数据库表<br>
2.基于数据库排他锁：result = select * from methodLock where method_name=xxx for update;if(result==null){return true;}<br>
3.基于缓存实现分布式锁：比如Tair的put方法，redis的setnx方法（通过超时时间来控制锁的失效时间并不是十分的靠谱。）<br>
4.基于Zookeeper实现分布式锁：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。<br>
阻塞可以通过CountDownLatch实现<br>
三种方案的比较<br>
上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。<br>
从理解的难易程度角度（从低到高）：数据库 > 缓存 > Zookeeper<br>
从实现的复杂性角度（从低到高）：Zookeeper >= 缓存 > 数据库<br>
从性能角度（从高到低）：缓存 > Zookeeper >= 数据库<br>
从可靠性角度（从高到低）：Zookeeper > 缓存 > 数据库<br>

8、分布式集群下如何做到唯一序列号。<br>
1. 数据库自增长序列或字段：针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。<br>
2. UUID：没有排序，无法保证趋势递增<br>
4. Redis生成ID<br>
5. Twitter的snowflake算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。<br>


9、设计一个秒杀系统，30 分钟没付款就:自动关闭交易。<br>
分流 – 限流 –异步 – 公平性（只能参加一次）–用户体验（第几位，多少分钟，一抢完） 容错处理 <br>

10、什么是一致性 hash。<br>
先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。<br>
这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。<br>

11、如何设计建立和保持 100w 的长连接。<br>
框架选择(netty)，JVM堆内存要配置大点，需要考虑到FULL GC的时间<br>

12、如何防止缓存雪崩<br>
缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。 <br>
解决思路： <br>
1，采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。 <br>
2，分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。 <br>
3，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。<br>


15、什么是 zab 协议。<br>
ZAB 是 Zookeeper 原子广播协议的简称<br>
整个ZAB协议主要包括消息广播和崩溃恢复两个过程，进一步可以分为三个阶段，分别是：<br>
发现 Discovery <br>
同步 Synchronization<br> 
广播 Broadcast <br>
组成ZAB协议的每一个分布式进程，都会循环执行这三个阶段，将这样一个循环称为一个主进程周期。 <br>

