1、Redis底层数据结构<br>
dict（字典），rehash触发条件（在没有持久化的情况下，1：1，否则是默认是5倍，数据量少于10%的情况会缩容）<br>

2、数据类型<br>
string、hash、list、set、sorted set（key是值，value是score，可用于score排序）<br>

3、如何保证缓存与数据库的双写一致性？<br>
一般先更新数据库，然后再删除缓存（可能有复杂的计算，lazy的思想），请求和写请求串行化，串到一个内存队列里去<br>
高并发一致性解决方案：（基于读写锁的思想）<br>
写线程：1、删除缓存 2、将数据ID_WRITE，写入redis（带过期时间），更新数据，删除缓存<br>
读线程：（所有的自旋等待需要加超时时间）1、发现缓存不存在，没有写锁，直接读数据库 2、写锁存在，第一个读的，将数据ID_READ，写入redis（带过期时间），等待写锁结束，去读取数据库，写入缓存 3、第二个读的，读锁存在，则等待<br>

4、redis 的雪崩、穿透和击穿<br>
缓存雪崩：缓存系统挂了、或缓存在同一时间都失效了，请求全部落在数据库了，解决方案：redis集群、本地缓存+限流+降级，redis持久化<br>
缓存穿透：访问不存在的key，导致不命中缓存，直接去查数据库了，解决方案：把不存在的key缓存到redis，value为null，带过期时间<br>
缓存击穿：一个key非常热点，访问非常多，当key失效的时候，很多请求全部落到数据库了，解决方案：1、设置永不过期，2、第一个请求将数据ID_READ，写入redis（带过期时间），去读取数据库，写入缓存，第二个读的，读锁存在，则等待<br>

5、redis 的并发竞争问题（先读取某个值，在本地处理完写回redis）<br>
使用redis或zookeeper获取分布式锁，再操作，最后释放锁<br>
使用redis的事物，watch监听某个key（exec前会去检查监听的key是否发生变化，变了exec直接返回null），multi开启事物，命令1命令2命令3，exec执行事物（exec，discard，unwatch命令都会清除连接中的所有监视）<br>

6、redis是单线程执行的，线程模型（为什么是非阻塞的可以用餐厅点菜举例）<br>
redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler。这个文件事件处理器，是单线程的，redis才叫做单线程的模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件<br>
I/O多路复用:<br>
一个服务器进程和一个客户端进程通信,服务器端read(sockfd1,bud,bufsize),此时客户端进程没有发送数据,那么read(阻塞调用)将阻塞直到客户端调用write(sockfd,but,size)发来数据. 在一个客户和服务器通信时这没什么问题,当多个客户与服务器通信时,若服务器阻塞于其中一个客户sockfd1,当另一个客户的数据到达套接字sockfd2时,服务器不能处理,仍然阻塞在read(sockfd1,...)上;此时问题就出现了,不能及时处理另一个客户的服务,咋么办?I/O多路复用来解决!<br>
继续上面的问题,有多个客户连接,sockfd1,sockfd2,sockfd3..sockfdn同时监听这n个客户,当其中有一个发来消息时就从select的阻塞中返回,然后就调用read读取收到消息的sockfd,然后又循环回select阻塞;这样就不会因为阻塞在其中一个上而不能处理另一个客户的消息<br>

7、redis内存回收策略<br>
noeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error<br>
allkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据<br>
volatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据<br>
allkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据<br>
volatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据<br>
volatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数<br>

8、redis 过期策略是？<br>
定期删除+惰性删除<br>

9、怎么实现消息的广播模式？<br>
基于redis的发布/订阅<br>

10、redis架构<br>
主从：主（写，开启持久化：不开启主节点挂了重启后数据是空的，从一复制，数据也空了）、从（读）<br>
哨兵：主（哨）、从（哨）、从（哨）<br>
集群（gossip 协议）：主从、主从、主从（hash solt算法，新加机器，不需要停机，需要迁移数据）<br>

11、redis持久化<br>
RDB 持久化机制：生成多个数据文件，适合做冷备，恢复速度快，丢失数据会比较多，数据文件特别大会影响redis对外提供服务<br>
AOF 机制：always/everysec/no，文件过大，恢复时间长，丢失数据少，但比较耗性能<br>

12、redis 的 list 结构相关的操作。<br>
LPUSH LPUSHX RPUSH RPUSHX LPOP RPOP BLPOP BRPOP LLEN LRANGE <br>
列表list包含三个元素：x, y, z，其中x是头元素，而z则是尾元素。<br>
LPUSH ：对一个空列表(mylist)执行LPUSH mylist a b c，则结果列表为c b a<br>

13、Redis 的数据结构都有哪些。<br>
字符串(strings)：存储整数（比如计数器）和字符串（废话。。），有些公司也用来存储json/pb等序列化数据，并不推荐，浪费内存 <br>
哈希表(hashes)：存储配置，对象（比如用户、商品），优点是可以存取部分key，对于经常变化的或者部分key要求atom（原子）操作的适合 <br>
列表(lists)：可以用来存最新用户动态，时间轴，优点是有序，确定是元素可重复，不去重 <br>
集合(sets)：无序，唯一，对于要求严格唯一性的可以使用 <br>
有序集合(sorted sets)：集合的有序版，很好用，对于排名之类的复杂场景可以考虑<br>


14、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。<br>
持久化方式：RDB时间点快照 AOF记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 LRU(近期最少使用算法)TTL（超时算法） 去除ttl最大的键值 <br>

15、3.0采用Cluster方式<br>
Redis集群相对单机在功能上存在一些限制， 需要开发人员提前了解， 在使用时做好规避。 限制如下： <br>
1） key批量操作支持有限。 如mset、 mget， 目前只支持具有相同slot值的 ke y执 行批量操作。 对于映射为不同slot值的key由于执行mget、 mget等操作可 能存在于多个节点上因此不被支持。 <br>
2） key事务操作支持有限。 同理只支持多key在同一节点上的事务操 作， 当多个key分布在不同的节点上时无法使用事务功能。 <br>
3） key作为数据分区的最小粒度， 因此不能将一个大的键值对象如 ha sh、 list等映射到不同的节点。 <br>
4） 不支持多数据库空间。 单机下的Redis可以支持16个数据库， 集群模 式下只能使用一个数据库空间， 即db0。<br> 
5） 复制结构只支持一层， 从节点只能复制主节点， 不支持嵌套树状复 制结构。 <br>

16、Memcache 的原理，哪些数据适合放在缓存中。<br>
基于libevent的事件处理 ，内置内存存储方式SLab Allocation机制 ， 基于客户端的分布式系统。变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线 状态、在线人数..) 门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入 到memcache中<br>

17、redis 和 memcached 的内存管理的区别。<br>
Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。 <br>
Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。 <br>
在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。 <br>

18、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗。<br>
Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：<br>
1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。<br>
2.服务器角度，利用setnx实现锁。<br>
MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：<br>
MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行 <br>
EXEC，告诉 Redis 开始执行事务 <br>
DISCARD，告诉 Redis 取消事务 <br>
WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。 <br>
可以利用watch实现cas乐观锁 <br>



Redis集群协议：Gossip协议（去中心化：Redis-Cluster不存在中心节点，每个节点都记录有集群的状态信息，并且通过Gossip协议，使每个节点记录的信息实现最终一致性；）
集群元数据(节点信息、故障等等)
https://www.jianshu.com/p/8279d6fd65bb
