
--- 1、volatile关键字在cpu层面的实现原理
https://juejin.im/post/5c6b99e66fb9a049d51a1094
为什么volatile能够保证变量在线程中的可见性？因为JVM就是通过volatile调动了缓存一致性机制，如果对使用了volatile的程序，查看JVM解释执行或者JIT编译后生成的汇编代码，你会发现对volatile域（被volatile修饰的共享变量）的写操作生成的汇编指令会有一个lock前缀，该lock前缀表示JVM会向CPU发送一个信号，这个信号有两个作用：

对该变量的改写立即刷新到主存（也就是说对volatile域的写会导致assgin -> store -> write的原子性执行）
通过总线通知其他CPU该共享变量已被更新，对于也缓存了该共享变量的CPU，如果接收到该通知，那么会在自己的Cache中将共享变量所在的缓存行置为无效状态。CPU在下次读取读取该共享变量时发现缓存行已被置为无效状态，他将重新到主存中读取。

你会发现这就是在底层启用了缓存一致性协议。也就是说对共享变量加上了volatile之后，每次对volatile域的写将会导致此次改写被立即刷新到主存并且后续任何对该volatile域的读操作都将重新从主存中读。

volatile禁止重排序
volatile的另一个语义就是禁止指令重排序，即volatile产生的汇编指令lock具有个指令屏障使得该屏障之前的指令不能重排序到屏障之后。这个作用使用单例模式的并发优化案例来说再好不过了。


--- 2、每个对象的对象头存储了具体哪些信息
mark world：对象的hash code，gc分代年龄，锁标志位（偏向锁：偏向的线程ID 轻量级锁的指针 重量级锁的指针）
类型指针：指向方法区该对象所属类的元数据信息
array length：只有数组对象的时候才会有

--- 3、开放关闭原则
强调设计和代码编写应当以在现有代码上改动最小的方式来完成新功能的添加。软件设计应尽可能在添加新功能类的时候不去改动现有代码。
应当对扩展开放，但对修改关闭。


--- 4、Happen-before原则
在Java中，有一些天生的先行发生原则供我们参考，通过这些规则我们能够判断两条程序的有序性（即是否存在一个先行发生于另一个的关系），从而决定是否有必要对其采取同步。

程序顺序规则：在单线程环境下，按照程序书写顺序，书写在前面的程序 happens-before 书写在后面的。
volatile变量规则：对一个volatile域的写 happens-before 随后对同一个volatile域的读。
监视器规则：一个线程释放其持有的锁对象 happens-before 随后其他线程（包括这个刚释放锁的线程）对该对象的加锁。
线程启动规则：对一个线程调用start方法 happens-before 执行这个线程的run方法
线程终止规则：t1线程调用t2.join，检测到t2线程的执行终止 happens-before t1线程从join方法返回
线程中断规则：对一个线程调用interrupt方法 happens-before 这个线程响应中断
对象终结规则：对一个对象的创建new happens-before 这个对象的finalize方法被调用
传递性：如果A happens-before B且B happens-before C，则有A happens-before C



--- 5、zookeeper分布式环境下发生脑裂怎么办
https://juejin.im/post/5d36c2f25188257f6a209d37
有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。


--- 6、zookeeper一定要是奇数嘛？
防止由脑裂造成的集群不可用。
在容错能力相同的情况下，奇数台更节省资源。
leader选举，要求 可用节点数量 > 总节点数量/2  。注意 是 > , 不是 ≥。

举两个例子：
(1) 假如zookeeper集群1 ，有3个节点，3/2=1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。
(2) 假如zookeeper集群2，有4个节点，4/2=2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。

那么问题就来了， 集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。




--- 7、redis的hash算法，为什么要用这个hash算法
https://blog.csdn.net/tianpeng341204/article/details/78963850
当前集群有3个节点,槽默认是平均分的:
节点 A （6381）包含 0 到 5499号哈希槽.
节点 B （6382）包含5500 到 10999 号哈希槽.
节点 C （6383）包含11000 到 16383号哈希槽.
这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.

数据迁移
数据迁移可以理解为slot(槽)和key的迁移，这个功能很重要，极大地方便了集群做线性扩展，以及实现平滑的扩容或缩容。



--- 8、redis锁发生死锁了，怎么办（一个线程获取了锁，当时redis集群挂了）
分布式锁需要解决的问题：
    1.互斥性:任一时刻是有一个客户端获取锁,不能两个客户端获取到锁
    2.安全性:锁只能被持有该客户端的删除,不能由其他客户端删除
    3.死锁:一个客户端获取到锁,导致宕机,而其他客户端无法获取到资源
    4.容错:一些节点宕机,客户端任然能获取锁和释放锁


解决办法1：对key设置过期时间

解决办法2：对key的写入值，添加一个字段，加上锁的有效时间（value = 线程ID + 锁有效时间）
首先看一下redis的GETSET这个操作，GETSET key value，将给定 key 的值设为 value ，并返回 key 的旧值(old value)。利用这个操作指令，我们改进一下上述的步骤。

A已经首先获得了锁 lock.id，然后线A断线。B,C都在等待竞争该锁；
B,C读取lock.id的值，比较当前时间和键 lock.id 的值来判断是否超时，发现超时；
B检测到锁已超时，即当前的时间大于键 lock.id 的值，B会执行
GETSET lock.id <current Unix timestamp + lock timeout + 1>设置时间戳，通过比较键 lock.id 的旧值是否小于当前时间，判断进程是否已获得锁；
B发现GETSET返回的值小于当前时间，则执行 DEL lock.id命令，并执行 SETNX lock.id 命令，并返回1，B获得锁；
C执行GETSET得到的时间大于当前时间，则继续等待。



--- 9、锁的各种状态，以及变化过程
https://blog.csdn.net/choukekai/article/details/63688332


--- 10、java中new一个对象分为几步？（所以在双重检查单例的代码中要使用volatile关键字）
allocMemory 	//为对象分配内存
<init>		    //执行对象构造器
return reference //返回对象在堆中的地址

而且上述三步是没有依赖关系的，这意味着他们可能被重排序成下面的样子：
allocMemory 	//为对象分配内存
return reference //返回对象在堆中的地址
<init>		    //执行对象构造器

