1、mysql查询执行计划<br>
要使用EXPLAIN,只需要在查询的SELECT关键字之前增加EXPLAIN这个词<br>
1.ID列<br>
是一位数字，表示执行SELECT语句的顺序。id值相同执行顺序从上到下。id值不同时id值大的先执行。<br>
2.SELECT_TYPE列<br>
SIMPLE：意味着查询不包括子查询和UNION。<br>
PRIMARY：查询有任何复杂的子部分，则最外层标记为PRIMARY.<br>
SUBQUERY：select列中子查询<br>
DEPENDENT SUBQUERY：依赖外部结果的子查询<br>
3.TYPE列（性能由高到低）<br>
system：这是const联接类型的一个特例。当查询的表只有一行时使用<br>
const：表中有且只有一个匹配的行时使用，如对主键或唯一索引的查询，这是效率最高的联接方式<br>
eq_ref：唯一索引或主键查找，对于每个索引键，表中只有一条记录<br>
ref：非唯一索引查找，返回匹配某个单独值的所有行<br>
ref_or_null：类似于red类型的查询，但是附加了对NULL值列的查询<br>
index_merge：该联接类型表示使用了索引合并优化方法<br>
range：索引范围查询，常见于between、>、<这样的<br>
index：FULL index scan全索引扫描，同ALL的区别是遍历的是索引树<br>
ALL：FULL table scan全表扫描，这是效率最差的联接方式<br>
4.ROWS<br>
表示MySQL通过哪些列或常量被用于查找索引列上的值，ROWS值的大小是个统计抽样结果，并不十分准确<br>

2、mysql查询一条sql的过程<br>
连接器
查询缓存 - 分析器（<br>
解析器：词法分析（从左到右一个字符、一个字符地输入，然后根据构词规则识别单词）、语法解析（生成语法树）<br>
预处理器：检查表名、列名，之后检查是否有此表的权限<br>
）<br>
优化器：是针对语法树进行优化，生成执行计划<br>
执行器<br>

3、ACID<br>
原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）<br>
持久性：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。<br>

4、间隙锁<br>
删除一个不存在的ID的时候，或锁住这个id范围内的数据（第一个小于、大于它的数），解决办法（在delete之前查询一下id是否存在）<br>

5、mysql存储引擎中Innodb和MyIsam区别<br>
事务：InnoDB具有事务和外键<br>
锁：MyISAM支持表级锁、InnoDB支持行级<br>
索引：InnoDB索引就是数据（主键），顺序存储，MyISAM索引和文件分开（索引data域保存数据记录的地址）<br>
并发：MyISAM读写互相阻塞（但读本身并不会阻塞另外的读），InnoDB 读写阻塞与事务隔离级别相关<br>

6、BTree和B+Tree的区别<br>
（1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。<br>
（2）mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。<br>

7、MVCC，Multi-Version Concurrency Control，多版本并发控制<br>
InnoDB存储引擎MVCC的实现策略（在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号）<br>
每行数据都存在一个版本，每次数据更新时都更新该版本。修改时Copy出当前版本随意修改，各个事务之间无干扰。保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）<br>
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.<br>
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。<br>
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。<br>
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。<br>

8、mysql共享锁与排他锁<br>
排他锁：有排他锁的情况下，排他查、共享查都会处于阻塞状态（因为数据已经被加上了排他锁，此处阻塞是等待排他锁释放），但是正常的select是查到数据的<br>
这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引<br>
共享锁：有共享锁的情况下，加排他锁就查不到，因为排他锁与共享锁不能存在同一数据上<br>
mysql InnoDb引擎中update,delete,insert语句自动加排他锁的问题<br>

9、分页查询优化<br>
原sql：SELECT * FROM loan_app LIMIT 100000,10;<br>
子查询优化：SELECT * FROM loan_app WHERE id > (SELECT id FROM loan_app LIMIT 100000,1) LIMIT 10;（适合不带查询条件的）<br>
连接查询优化：SELECT * FROM loan_app a1 JOIN (SELECT id FROM loan_app LIMIT 100000,10) as a2 ON a1.id = a2.id;（适合带条件查询的）<br>

10、hash索引<br>
等值查询，那么哈希索引明显有绝对优势，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索，同理，哈希索引也没办法利用索引完成排序，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。<br>

11、组合索引B+tree<br>
联合索引(col1, col2,col3)也是一棵B+Tree，其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。<br>

12、数据库隔离级别有哪些，各自的含义是什么，MYSQL 默认的隔离级别是是什么。<br>
·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据<br>
·提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)<br>
·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读<br>
·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，MYSQL默认是RepeatedRead级别<br>

14、高并发下，如何做到安全的修改同一行数据。<br>
使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。 也可以缓存队列中锁定主键。<br>

15、乐观锁和悲观锁是什么，INNODB 的行级锁有哪 2 种，解释其含义。<br>
乐观锁是设定每次修改都不会冲突，只在提交的时候去检查，悲观锁设定每次修改都会冲突，持有排他锁。 <br>
行级锁分为共享锁和排他锁两种 共享锁又称读锁 排他锁又称写锁 <br>

16、SQL 优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。<br>
查看慢日志（show [session|gobal] status ），定位慢查询，查看慢查询执行计划 根据执行计划确认优化方案 <br>
Explain sql <br>
select_type:表示select类型。常见的取值有SIMPLE（简单表，即不使用连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（union中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。 <br>
talbe：输出结果集的表。 <br>
type:表的连接类型。性能由高到底：system（表中仅有一行）、const（表中最多有一个匹配行）、eq_ref、ref、ref_null、index_merge、unique_subquery、index_subquery、range、idnex等 <br>
possible_keys:查询时，可能使用的索引 <br>
key:实际使用的索引 <br>
key_len:索引字段的长度 <br>
rows：扫描行的数量 <br>
Extra：执行情况的说明和描述 <br>

17、数据库会死锁吗，举一个死锁的例子，mysql 怎么解决死锁。<br>
产生死锁的原因主要是：（1）系统资源不足。 （2） 进程运行推进的顺序不合适。 （3）资源分配不当等。<br>
如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。<br>
这里提供两个解决数据库死锁的方法：1）重启数据库（谁用谁知道） 2）杀掉抢资源的进程<br>

18、MYsql 的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。<br>
索引是通过复杂的算法，提高数据查询性能的手段。从磁盘io到内存io的转变 <br>
普通索引，主键，唯一，单列/多列索引建索引的几大原则 <br>
1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 <br>
2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 <br>
3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录 <br>
4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’); <br>
5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可<br>


19、聚集索引和非聚集索引的区别。<br>
“聚簇”就是索引和记录紧密在一起。 <br>
非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块。<br>

20、数据库中 BTREE 和 B+tree 区别。<br>
21、Btree 怎么分裂的，什么时候分裂，为什么是平衡的。 <br>

22、如何写 sql 能够有效的使用到复合索引。<br>
由于复合索引的组合索引，类似多个木板拼接在一起，如果中间断了就无法用了，所以要能用到复合索引，首先开头(第一列)要用上，比如index(a,b) 这种，我们可以select table tname where a=XX 用到第一列索引 如果想用第二列 可以 and b=XX 或者and b like‘TTT%’<br>

23、mysql 中 in 和 exists 区别。<br>
#对B查询涉及id，使用索引，故B表效率高，可用大表 -->外小内大（select * from A where exists (select * from B where A.id=B.id);）<br>
#对A查询涉及id，使用索引，故A表效率高，可用大表 -->外大内小（select * from A where A.id in (select id from B);）<br>
1、exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；<br>
2、in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。<br>
3、如果用not in ，则是内外表都全表扫描，无索引，效率低，可考虑使用not exists，也可使用A left join B on A.id=B.id where B.id is null 进行优化。<br>

23、数据库自增主键可能的问题。<br>
在分库分表时可能会生成重复主键（利用自增比例达到唯一 自增1 2,3 等来解决） <br>

24、char和varchar的区别<br>
CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检 索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义 char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。<br>
VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间，(VARCHAR的最大有效长度由最大行大小和使用 的字符集确定。整体最大长度是65,532字节）。VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则 使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。varchar存储变长数据，但存储效率没有 CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么”+1″呢？这一个字节用于保存实际使用了多大的长度。 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。<br>
CHAR和VARCHAR最大的不同就是一个是固定长度，一个是可变长度。由于是可变长度，因此实际存储的时候是实际字符串再加上一个记录 字符串长度的字节(如果超过255则需要两个字节)。如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉 的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。<br>

25、ACID 是什么。<br>
A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。 <br>
C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏 <br>
I，isolation，隔离性，并发事物间相互不影响，互不干扰。 <br>
D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。<br>

事务ACID: 
原子性，指的是整个事务要么全部成功，要么全部失败，对InnoDB来说，只要client收到server发送过来的commit成功报文，那么这个事务一定是成功的。如果收到的是rollback的成功报文，那么整个事务的所有操作一定都要被回滚掉，就好像什么都没执行过一样。另外，如果连接中途断开或者server crash事务也要保证会滚掉。InnoDB通过undolog保证rollback的时候能找到之前的数据。
一致性，指的是在任何时刻，包括数据库正常提供服务的时候，数据库从异常中恢复过来的时候，数据都是一致的，保证不会读到中间状态的数据。在InnoDB中，主要通过crash recovery和double write buffer的机制保证数据的一致性。
隔离性，指的是多个事务可以同时对数据进行修改，但是相互不影响。InnoDB中，依据不同的业务场景，有四种隔离级别可以选择。默认是RR隔离级别，因为相比于RC，InnoDB的RR性能更加好。
持久性，值的是事务commit的数据在任何情况下都不能丢。在内部实现中，InnoDB通过redolog保证已经commit的数据一定不会丢失。


InnoDB存储引擎的锁的算法有三种：
Record lock：单个行记录上的锁
Gap lock：间隙锁，锁定一个范围，不包括记录本身
Next-key lock：record+gap 锁定一个范围，包含记录本身
相关知识点：

innodb对于行的查询使用next-key lock
Next-locking keying为了解决Phantom Problem幻读问题
当查询的索引含有唯一属性时，将next-key lock降级为record key
Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

