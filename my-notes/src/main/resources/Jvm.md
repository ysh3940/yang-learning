1、jvm线上怎么调优<br>
https://xie.infoq.cn/article/2d78c54cc0c3b65acc289029a

2、各个回收器，适合用在什么场景下<br>

3、判断哪些对象是垃圾<br>
引用计数算法：有一个缺陷，就是无法解决对象之间相互循环引用的问题<br>
可达性分析算法：基本思路就是通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>
作为GC Roots的对象包括下面几种：<br>
虚拟机栈（栈帧中的本地变量表）中的引用对象。<br>
方法区中类静态属性的引用对象。<br>
方法区中的常量引用对象。<br>
本地方法栈中JNI（即一般说的Native方法）的引用对象。<br>

4、内存泄露<br>
生命周期的对象持有短生命周期对象的引用。
无用的对象给其他地方意外的持有，导致其是可达的，因此判定它不是可回收的对象。<br>
java中内存泄露场景
4.1、使用静态的集合类
    静态的集合类的生命周期和应用程序的生命周期一样长，所以在程序结束前容器中的对象不能被释放，会造成内存泄露。解决办法是最好不使用静态的集合类，如果使用的话，在不需要容器时要将其赋值为null。
4.2 、单例模式可能会造成内存泄露
    单例模式只允许应用程序存在一个实例对象，并且这个实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收。解决办法是单例对象中持有的其他对象使用弱引用，弱引用对象在GC线程工作时，其占用的内存会被回收掉。
4.3 、变量不合理的作用域
如果变量的定义范围大于使用范围，并且在使用完后没有赋值为null的话，会出现内存泄露。定义变量的时候，能定义为局部变量就不要定义为成员变量，或者定义为成员变量的话，在使用完变量后，把变量赋值为null。
4.4、数据库、网络、输入输出流，这些资源没有显示的关闭
    垃圾回收只负责内存回收，如果对象正在使用资源的话，Java虚拟机不能判断这些对象是不是正在进行操作，比如输入输出，也就不能回收这些对象占用的内存，所以在资源使用完后要调用close()方法关闭。



5、JVM堆模型/分代<br>
JVM将堆分成了二个大区新生代（Young）和老年代（Old），新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成，也有些人把FromSpace和ToSpace叫成Survivor1和Survivor2。<br>
新生代<br>
新创建的对象都是在新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br>

老年代<br>
老年代用于存放经过多次Minor GC之后依然存活的对象。<br>

新生代的GC（Minor GC）<br>
新生代通常存活时间较短，其基于复制算法进行回收。复制算法就是扫描出存活的对象，然后复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间复制。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。<br>

老年代的GC（Major GC/Full GC）<br>
老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。<br>

6、垃圾收集算法<br>
标记-清除算法：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>
复制算法：只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。新生代的回收都是基于复制算法来实现，只是会进行优化，具体可以看下前面 新生代的GC 这一块的内容。<br>
标记-整理算法：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br>
分代收集算法：把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>

7、什么情况下会发生栈内存溢出。<br>
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 <br>
如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 <br>

8、jvm 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm 参数。<br>
对象诞生即新生代->eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代<br>

9、你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点<br>
Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1 <br>
Serial收集器：Serial收集器是一个新生代收集器，单线程执行，使用复制算法。<br>
ParNew收集器：ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。<br>
Parallel Scavenge收集器：Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器，parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。<br>

Serial Old收集器：Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记－整理”算法。<br>
Parallel Old 收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。<br>

CMS 收集器（Concurrent Mark Sweep）：是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记—清除”算法实现的。<br>
初始标记（CMS initial mark）：需要“Stop The World”<br>
并发标记（CMS concurrent mark）<br>
重新标记（CMS remark）：需要“Stop The World”<br>
并发清除（CMS concurrent sweep）<br>
CMS是一款基于“标记—清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。<br>

G1收集器：<br>
并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。<br>
分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>
空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>
可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。<br>
在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。<br>
    
10、当出现了内存溢出，你怎么排错。<br>
年老代堆空间被占满，异常： java.lang.OutOfMemoryError: Java heap space（代码内的内存泄漏可以通过一些分析工具进行分析，然后找出泄漏点进行改善。第二种原因导致的OutOfMemoryError可以通过，优化代码和增加Survivor Space等方式去优化。）<br>
持久代被占满（大量使用反射），异常：java.lang.OutOfMemoryError: PermGen space（增加持久代的空间 -XX:MaxPermSize=100M。如果有自定义类加载的需要排查下自己的代码问题。）<br>
堆栈溢出，异常：java.lang.StackOverflowError（一般就是递归没返回，或者循环调用造成）<br>
线程堆栈满，异常：Fatal: Stack size too small（解决：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。）<br>

优化GC步骤：<br>
首先需要观察目前垃圾回收的情况，分析出老年代和年轻代回收的情况，适当的去调整内存大小和-XX:SurvivorRatio的比例。<br>
根据垃圾收集器的特性，选择适合自己业务的垃圾收集器，一般来说现在的WEB服务都是CMS＋ParNew收集器。根据CMS收集器一般来说就会产生大量碎片，根据自己的需求选择相应的压缩频率即可。<br>
不断的调整jvm内存比例，老年代、年轻代、以及持久代的比例，直到测试出一个比较满意的值。<br>


11、JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。<br>
内存屏障：为了保障执行顺序和可见性的一条cpu指令 <br>
重排序：为了提高性能，编译器和处理器会对执行进行重拍 <br>

happen-before：操作间执行的顺序关系。有些操作先发生。 <br>
1.单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。
2.锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
3.volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。
4.happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
5.线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。
6.线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
7.线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。
8.对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。

主内存：共享变量存储的区域即是主内存 <br>
工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本 <br>

12、简单说说你了解的类加载器。<br>
启动（Bootstrap）类加载器，扩展（Extension）类加载器-ExtClassLoader，系统（System）类加载器-AppClassLoader
1.加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
2.验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
3.准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
4.解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。
5.初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。


13、讲讲 JAVA 的反射机制。<br>


14、g1 和 cms 区别,吞吐量优先（适合在后台运算而不需要很多交互的任务）和响应优先的垃圾收集器选择。<br>
Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。 <br>
G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控。 <br>

15、请解释如下 jvm 参数的含义： <br>
-server -Xms512m -Xmx512m -Xss1024K <br>
-XX:PermSize=256m -XX:MaxPermSize=512m <br>
-XX:MaxTenuringThreshold=20 <br>
XX:CMSInitiatingOccupancyFraction=80 <br>
-XX:+UseCMSInitiatingOccupancyOnly<br>

Server模式启动 <br>
最小堆内存512m <br>
最大512m <br>
每个线程栈空间1m <br> 
永久代256 <br>
最大永久代256 <br>
最大转为老年代检查次数20 <br>
Cms回收开启时机：内存占用80% <br>
命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期 <br>

至于 “浮动垃圾”，因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。
